## 同步异步和阻塞非阻塞

> 同步异步和阻塞非阻塞是两组不同的概念, 彼此没有关系。

下面的内容来自: [以goroutine为例看协程的相关概念](http://www.cnblogs.com/diegodu/p/5607627.html)

### 同步、异步

同步与异步的区别， 主要关注的是消息通信机制。

所谓同步调用， 就是由调用者主动等待这个调用结果。发出一个调用， 在没有得到结果之前， 该调用就不返回。一旦调用返回， 就得到返回值了。

异步调用， 就是在调用发出之后， 这个调用就直接返回了。当一个异步调用过程发出之后， 调用者不会立即得到结果， 而是在调用发出后， 被调用者通过状态、通知来通知调用者， 或者通过函数回调来处理这个调用。



### 阻塞、非阻塞

阻塞与非阻塞 关注的是:程序在等待调用结果（消息 返回值）时的状态

阻塞调用 是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。

非阻塞调用 是指，在不能立刻得到结果之前，该调用不会阻塞当前线程，当前线程还会继续执行下去。

从io角度上来理解阻塞和非阻塞应该更为恰当。必须等待io完成，当前线程才能继续执行，就是一种典型的阻塞。阻塞一旦发生，程序就会挂起，将会让出cpu时间片，这点与同步异步是不同的。



### IO多路复用

> IO多路复用包括select, poll, epoll， 这些都属于同步，还不属于异步。

- **select**

  select通过一个select()系统调用来监视多个文件描述符的数组，该数组中就绪的文件描述符就会被内核修改标志位， 使得进程可以获得这些文件描述符从而进行后续的读写操作。

  select的跨平台支持较好，但其最大的缺点在于当个进程能够监视的文件描述符的数量存在最大限制， 此外select()所维护的存储大量文件描述符的数据结构会随着文件描述符数量的增大，在内核态和用户态之间的复制开销也线性增长。

- **poll**

  poll和select本质上没有区别， 但poll没有最大文件描述符数量的限制。poll和select同样存在一个缺点就是，包含大量文件描述符的数组被整体复制于用户态和内核的地址空间之间，而不论这些文件描述符是否就绪，它的开销随着文件描述符数量的增加而线性增大。

  另外，select()和poll()将就绪的文件描述符告诉进程后，如果进程没有对其进行IO操作，那么下次调用select()和poll()的时候将再次报告这些文件描述符，所以它们一般不会丢失就绪的消息，这种方式称为水平触发。

- **epoll**

  epoll可以同时支持水平触发和边缘触发（Edge Triggered，只告诉进程哪些文件描述符刚刚变为就绪状态，它只说一遍，如果我们没有采取行动，那么它将不会再次告知，这种方式称为边缘触发），理论上边缘触发的性能要更高一些，但是代码实现相当复杂。

  epoll同样只告知那些就绪的文件描述符，而且当我们调用epoll_wait()获得就绪文件描述符时，返回的不是实际的描述符，而是一个代表就绪描述符数量的值，你只需要去epoll指定的一个数组中依次取得相应数量的文件描述符即可，这里也使用了内存映射（mmap）技术，这样便彻底省掉了这些文件描述符在系统调用时复制的开销。

  另一个本质的改进在于epoll采用基于事件的就绪通知方式。在select/poll中，进程只有在调用一定的方法后，内核才对所有监视的文件描述符进行扫描，而epoll事先通过epoll_ctl()来注册一个文件描述符，一旦基于某个文件描述符就绪时，内核会采用类似callback的回调机制，迅速激活这个文件描述符，当进程调用epoll_wait()时便得到通知。



| IO多路复用类别 | 最大文件描述符限制 | 文件描述符扫描 | 备足                                |
| -------------- | :----------------: | -------------- | ----------------------------------- |
| **select**     |         Y          | Y              | 所有监视的文件描述符扫描（for循环） |
| **poll**       |         N          | Y              | 同select                            |
| **epoll**      |         N          | N              | 事件就绪通知方式                    |

