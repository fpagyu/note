## Mysql InnoDB 索引原理



### 聚集索引(clustered index)

innodb存储引擎表是索引组织表， 表中数据按照主键顺序存放。其聚集索引就是按照每张表的主键顺序构造一颗B+树，其叶子结点中存放的就是整张表的行记录数据， 这些叶子结点成为数据页。

聚集索引的存储并不是物理上连续的， 而是逻辑上连续的，叶子结点间按照主键顺序排序， 通过双向链表连接。多数情况下， 查询优化器倾向于采用聚集索引， 因为聚集索引能在叶子结点直接找到数据，并且因为定义了数据的逻辑顺序，能特别快的访问针对范围值的查询。

聚集索引的这个特性决定了索引组织表中的数据也是索引的一部分。由于表里的数据只能按照一颗B+树排序， 因此一张表只能有一个聚簇索引。

在innodb中，聚簇索引默认就是主键索引， 如果没有主键索引，则按照下列规则来建聚簇索引：

> 没有主键时， 会用一个非空并且唯一的索引作为主键， 成为此表的聚簇索引
>
> 如果没有这样的索引，innodb会隐式定义一个主键来作为聚簇索引

由于主键使用了聚簇索引， 如果主键是自增id， 那么对应的数据也会相邻地存放在磁盘上， 写入性能比较高， 如果是uuid等字符串形式，频繁的插入操作会使innodb频繁地移动磁盘块，写入性能就比较低。

#### **B+树（多路平衡二叉树）**

使用B+树而不是二叉树的原因:

计算机在存储数据的时候有最小存储单元， 文件系统的最小单元是块， 一个块的大小是4k(这个值根据系统不同并且可以设置), InnoDB存储引擎也有自己的最小存储单元-页(page), 一个页的大小是16K（这个值的大小也是可以设置的）。

文件系统中一个文件的大小只有1字节， 但不得不占用磁盘上4kb的空间。同理，innodb的所有数据文件的大小始终都是16384（16k）的整数倍。

所以在Mysql中， 存放索引的一个块结点占16k， mysql每次IO操作都会利用系统的预读能力一次加载16K。这样， 如果这一个结点只放1个索引是非常浪费的，因为一次IO只能获取一个索引值， 所以不能使用二叉树。

B+树是多路查找树， 一个结点能放n个值， n=16K/每个索引值的大小。

例如索引字段大小1kb， 这时候每个结点能放的索引值理论上是16个，这种情况下二叉树一次IO只能加载一个索引值， 而B+树能加载16个。

B+树的路数为n+1，n是每个节点存在的值数量，例如每个节点存放16个值，那么这棵树就是17路。

从这里也能看出，B+树节点可存储多个值，所以B+树索引并不能找到一个给定键值的具体行。B+树只能找到存放数据行的具体页，然后把页读入到内存中，再在内存中查找指定的数据。

附：B树和B+树的区别在于，B+树的非叶子结点只包含导航信息，不包含实际的值，所有的叶子结点和相连的节点使用链表相连，便于区间查找和遍历。



### 非聚集索引(辅助索引)

非聚集索引，其叶子结点不包含记录的全部数据，叶子结点除了包含键值以外，每个叶子结点中的索引行还包含一个书签，该书签就是相应行的聚集索引键。

当通过辅助索引来查找数据时， innodb存储引擎会通过辅助索引叶子结点获得指向聚集索引的主键， 然后再通过主键索引找到完整的行记录。

创建的索引，如联合索引、唯一索引等， 都属于非聚簇索引。



#### 联合索引

联合索引是指对表上的多个列进行索引。联合索引也是一颗B+树， 不同的是联合索引的键值数量不是1， 而是大于等于2。

例如有user表， 字段为id， age， name， 现发现如下两条sql使用频率最高：

```sql
select * from user where age = ?;
select * from user where age = ? and name = ?;
```

这时候不需要为age和name单独建两个索引， 只需要建如下一个索引即可:

```sql
create index idx_age_name on user(age, name);
```

联合索引的另一个好处是已经对第二个键值进行了排序处理， 有时候可以避免多一次的排序操作。

#### 覆盖索引

覆盖索引，即从辅助索引中就可以得到查询所需要的所有字段值， 而不需要查询聚集索引中的记录。覆盖索引的好处是辅助索引不包含整行记录的所有信息， 故其要远小于聚集索引， 因此可以减少大量io操作。

例如上面有联合索引(age, name)， 如果如下：

```sql
select age， name from user where age = ?;
```

就能使用覆盖索引了。

覆盖索引的另一个好处是对于统计问题， 例如:

```sql
select count(*) from user
```

innodb 存储引擎并不会选择通过查询聚集索引来进行统计。由于user表上还有辅助索引， 而辅助索引远小于聚集索引， 选择辅助索引可以减少IO。



### 注意事项

- 索引只建合适的，不建多余的

> 因为每当增删数据时，B+树都要进行调整，如果建立多个索引，多个B+树都要进行调整，而树越多、结构越庞大，这个调整越是耗时耗资源。如果减少了这些不必要的索引，磁盘的使用率可能会大大降低。

- 索引列的数据长度能少则少。

```
索引数据长度越小，每个块中存储的索引数量越多，一次IO获取的值更多。
```

- 匹配列前缀可用到索引 like 9999%，like %9999%、like %9999用不到索引；
- Where 条件中in和or可以使用索引， not in 和 <>操作无法使用索引；

```
如果是not in或<>，面对B+树，引擎根本不知道应该从哪个节点入手。
```

- 匹配范围值，order by 也可用到索引；
- 多用指定列查询，只返回自己想到的数据列，少用select *；

```
不需要查询无用字段，并且不使用*可能还会命中覆盖索引哦；
```

- 联合索引中如果不是按照索引最左列开始查找，无法使用索引；

```
最左匹配原则；
```

- 联合索引中精确匹配最左前列并范围匹配另外一列可以用到索引；
- 联合索引中如果查询中有某个列的范围查询，则其右边的所有列都无法使用索